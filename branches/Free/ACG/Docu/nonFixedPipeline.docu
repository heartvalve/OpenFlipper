/** \page NonFixedPipelinePage The non-fixed OpenGL rendering pipeline
On this page we will explain how to use the non-fixed (modern) OpenGL rendering pipeline in OpenFlipper.
First let us introduce the necessary classes.

\section baseNode The BaseNode in the Scenegraph

\section iRenderer The IRenderer interface
The IRenderer interface can be derived from and used to attach a RenderObject via the addRenderObject function from within each node within the Scenegraph that is
to be rendered.

\subsection renderObject Defining RenderObjects
The RenderObject class can be used to define the vertex buffer objects and set further information for the scene nodes.

\section vertexDeclaration Defining the layout of a vertex element
The VertexDeclaration class is used to specify the layout of a vertex element (VertexElement)

\section shaderGenerator Generating GLSL shaders

The \subpage ShaderGenerator_page class can be used to generate default GLSL shader code.
It is possible to have the complete shader generated with typical shading options such as phong or flat shading.
Alternatively the main function can be fully customized via template files or ShaderModifiers.
Template files are specified in ShaderGenDesc::vertexTemplateFile and ShaderGenDesc::fragmentTemplateFile and 
they extend the generated code by a user defined main function. Shader vertex I/O attributes and uniforms can also be
user defined; however, make sure that there is no name conflict with the generated shader code.
Example: A vertex offset operation based on normals is accomplished with the following template file:
\code
void main()
{
  // default vertex transforms are handled by the generator by replacing the SG_VERTEX_BEGIN with generated code
  SG_VERTEX_BEGIN
  
#ifdef SG_NORMALS
  sg_vPosPS = g_mWVP * (inPosition + vec4(inNormal, 0));
#endif
  
  SG_VERTEX_END
}
\endcode

But templates are optional and are not needed to generate shaders for mimicking the fixed function pipeline.
Alternatively, ShaderModifiers are useful for global shading effects which only change few code lines
and are also combinable with each other allowing a more dynamic shader customization.
The Depth-Peeling renderer shows how to use these modifiers.


\subsection shaderCache The Shader Cache
The Shader Cache singleton class should be used to manage the used shaders. You can query a shader
from the cache via a shader description. If it is already available, it will be returned from
the cache. Otherwise, it is compiled and linked. This ensures more efficient and
redundancy free shader management. ( ACG::ShaderCache )


\subsection glslShader The GLSL Shader
The Shader class is a helper class for building and using GLSL programs


\subsection Draw Modes

A DrawMode is a set of properties that describe how to present an object (i.e. wireframe, textured, flat-shaded...).
There are two types of Drawmodes: bitflags and property-based.
Bitflags are a combination of predefined Drawmodes such as SOLID_SMOOTH_SHADED and WIREFRAME.
Afterwards it can be tested with the bitwise & operator whether it contains such an atomic DrawMode.

Property-based draw modes use a different approach by defining a set of properties for an atomic DrawMode.
These settings are stored in the DrawModeProperties structure.
Support for combined drawmodes is possible by adding a new layer for each atomic drawmode.
Each layer is represented by one atomic DrawModeProperties structure.
Initially each property-based draw mode consists of exactly one layer which is equivalent to an atomic draw mode.
If we also want to render the wireframe or halfedge representation of an object in combination with a solid mode,
we can fill out a DrawModeProperties struct for that purpose and call DrawMode::addLayer() to combine wireframe and solid mode.

A scenegraph node can iterate over each layer of a Drawmode via getNumLayers() and getLayer()
and draw its object according to the properties of that layer.

Example:
Draw with gouraud shading:

\code
DrawModeProperties props;
props.lightStage(LIGHTSTAGE_SMOOTH); // lighting should be done in vertex shader
props.normalSource(NORMAL_PER_VERTEX); // use smooth vertex normals

drawMode.setDrawModeProperties(props); // assign to layer 0
\endcode


Draw with phong lighting:

\code
DrawModeProperties props;
props.lightStage(LIGHTSTAGE_PHONG); // lighting should be done in fragment shader
props.normalSource(NORMAL_PER_VERTEX); // use smooth vertex normals

drawMode.setDrawModeProperties(props); // assign to layer 0
\endcode


Draw with flat shading and wireframe (2 layers):

\code
// define flat shading properties
DrawModeProperties props;
props.lightStage(LIGHTSTAGE_SMOOTH); // lighting should be done in vertex shader
props.normalSource(NORMAL_PER_FACE); // use per face normals

drawMode.setDrawModeProperties(props); // assign flat shading to layer 0

// define unlit properties for wireframe rendering
props.primitive(PRIMITIVE_WIREFRAME); // use wireframe instead of solid faces
props.lightStage(LIGHTSTAGE_UNLIT); // no lighting 

drawMode.addLayer(&props); // assign wireframe to layer 1
\endcode

The object is then rendered in two passes (one for each layer) with different shader programs.
Note that the light stage tells the shader generator whether to do the lighting in vertex or fragment shader or to skip it entirely.
Then a combination of lighting functions are added to the shader code based on the light configuration in the ShaderGenDesc structure.

Example based on a DIRECTIONAL, DIRECTIONAL, POINTLIGHT configuration:
\code
sg_cColor.xyz += LitDirLight(sg_vPosVS.xyz, sg_vNormalVS, g_vLightDir_0,  g_cLightAmbient_0,  g_cLightDiffuse_0,  g_cLightSpecular_0);
sg_cColor.xyz += LitDirLight(sg_vPosVS.xyz, sg_vNormalVS, g_vLightDir_1,  g_cLightAmbient_1,  g_cLightDiffuse_1,  g_cLightSpecular_1);
sg_cColor.xyz += LitPointLight(sg_vPosVS.xyz, sg_vNormalVS,  g_vLightPos_2,  g_cLightAmbient_2,  g_cLightDiffuse_2,  g_cLightSpecular_2, g_vLightAtten_2);
\endcode



\section creating_new_renderer_plugins Creating new renderer plugins

The rendering pipeline is fully customizable via external plugins.
Each shader-based renderer is represented by a subclass of RenderInterface and ACG::IRenderer, 
where RenderInterface enables the renderer to be selected in the viewport of OpenFlipper (right-click on coordinate-axis -> Renderers -> "renderer-name").
and ACG::IRenderer provides the connection of scenegraph-nodes to the renderer.
Additionally further helper-functions are already implemented in IRenderer such as
the collection and sorting of RenderObjects and basic rendering procedures of RenderObjects,
but the scene rendering routine must be implemented in the plugin.
Plugin-Render-ShaderPipeline is a minimal example of a simple rendering-plugin.

Rendering code is implemented in the render() function inherited by RenderInterface and should always look like this:

\code
void Renderer::render(ACG::GLState* _glState, Viewer::ViewerProperties& _properties)
{
  // collect renderobjects + prepare OpenGL state
  prepareRenderingPipeline(_glState, _properties.drawMode(), PluginFunctions::getSceneGraphRootNode());

  // clear back buffer
  ACG::Vec4f clearColor = _properties.backgroundColor();
  glClearColor(clearColor[0], clearColor[1], clearColor[2], 1.0f);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);


  // render every object
  for (int i = 0; i < getNumRenderObjects(); ++i)
    renderObject(sortedObjects_[i]);

  // restore common opengl state
  // log window remains hidden otherwise
  finishRenderingPipeline();
}
\endcode


The code begins and ends by calling prepareRenderingPipeline() and finishRenderingPipeline() 
which are helper-functions of IRenderer.
Here, prepareRenderingPipeline traverses the scenegraph to collect render-objects, sorts them
by priority in ascending order.
The sorted list of renderobjects is then stored in the sortedObjects_ array, inherited of IRenderer.
We then proceed to clear the back buffer and render each object with another helper-function: renderObject().
renderObject() prepares OpenGL states (vertex/index source, boolean glEnable states..), 
sets shader uniforms according the data in the RenderObject structure and executes the draw call.
Furthermore it is possible to force the use of a shader or disallow any changes made via glEnable/glDisable
by specifying the 2nd and 3rd parameter of renderObject().
Note that renderObject() is only a helper-function and may also be ignored and implemented on your own.
Finally, finishRenderingPipeline() resets the OpenGL state machine such that it does not
interfere with following draw-calls made by Qt.

The depth-peeling renderer plugin is a more complex example, but showcases the flexibility of the renderer interface.
It makes use of global shader effects which are fully integrated to the shader-generation pipeline.
Only small changes to an existing shader have to be made in order to implement depth peeling and
thus the concept of ShaderModifiers is used here.
Take a look at the PeelShaderModifier for example:

\code
class PeelLayerModifier : public ShaderModifier
{
public:


  void modifyFragmentIO(ShaderGenerator* _shader)
  {
    _shader->addUniform("sampler2D g_DepthLayer");
  }

  void modifyFragmentBeginCode(QStringList* _code)
  {
    // compare current depth with previous layer
    _code->push_back("float dp_prevDepth = texture(g_DepthLayer, sg_vScreenPos).x;");
    _code->push_back("if (gl_FragCoord.z <= dp_prevDepth) discard;");
  }

  void modifyFragmentEndCode(QStringList* _code)
  {
    _code->push_back("outFragment = vec4(sg_cColor.rgb * sg_cColor.a, sg_cColor.a);");
  }

  static PeelLayerModifier instance;
};
\endcode

Applying this modifier to the shader generator will result in a new uniform in the
fragment shader (sampler2D g_DepthLayer) and a slightly modified fragment shader.
modifyFragmentBeginCode() adds shader-code before the fragment lighting stage and 
modifyFragmentEndCode() adds shader-code at the end of the main() function of the shader.
Obviously, these code excerpts have to comply to the naming convention of the shader-generator.

We have to register each modifier to the shader generator:

\code
ShaderProgGenerator::registerModifier(&PeelLayerModifier::instance);
\endcode

Later in the render() function we can make use of this modifier via getProgram() of ShaderCache:

\code
GLSL::Program* peelProg = ShaderCache::getInstance()->getProgram(&sortedObjects_[k]->shaderDesc, PeelLayerModifier::instance);
peelProg->use();
peelProg->setUniform("g_DepthLayer", 4);

renderObject(sortedObjects_[k], peelProg, true);
\endcode

Multiple shader modifiers can be applied to one shader, but the order of modifiers is undefined.

\code
ShaderCache::getInstance()->getProgram(&shaderDesc, ModifierA_ID | ModifierB_ID);
\endcode

\section shader_template_files Shader template files

Shader generation can be controlled with shader template files.
These template files contain custom shader code and are later extended by the ShaderGenerator.
Obviously, only one template at a time can be used by the ShaderGenerator, so render-plugins
should prefer modifiers to retain combinational flexibility.


Example template:
The depth-peeling effect can also be achieved with templates instead of shader-modifiers.

\code
// declare custom uniforms
uniform sampler2D g_DepthLayer;

// the generator takes care of all essential uniforms

void main()
{
  // At first, the generator calculates sg_vScreenPos and sg_cColor for us here
  SG_FRAGMENT_BEGIN; // begin code marker, insert generated code here

  
  
  // customized peeling code
  float dp_prevDepth = texture(g_DepthLayer, sg_vScreenPos).x;
  if (gl_FragCoord.z <= dp_prevDepth) discard;

  
  // end of fragment shader
  SG_FRAGMENT_END; // end code marker

  
  // overwrite color output of generator for peel-layer blending
  outFragment = vec4(sg_cColor.rgb * sg_cColor.a, sg_cColor.a);
}
\endcode

Assume that this template file is stored at  ShaderDir/DepthPeeling/peelLayer.template,
then the peel shader is assembled as follows:

\code
// QString to fragment shader template
QString qstrInitTemplate = OpenFlipper::Options::shaderDirStr() + QDir::separator() + QString("DepthPeeling/peelLayer.template");

// make temp-copy of ShaderGenDesc 
ShaderGenDesc peelDesc = sortedObjects_[k]->shaderDesc;

// specify template string
std::string strTemplateFile = qstrInitTemplate.toStdString();
peelDesc.fragmentTemplateFile = strTemplateFile.c_str();

// query shader-program from cache
GLSL::Program* peelProg = ShaderCache::getInstance()->getProgram(&peelDesc);
\endcode

Keep in mind that this technique eventually overwrites any template set by scenegraph-nodes.


\section acg_debugging_tips_and_tricks Debugging tips and tricks


The most important function for debugging dumpRenderObjects() is provided by ACG::IRenderer.
This can be called after call to prepareRenderingPipeline() and it creates a text file
containing a full data dump of all render objects with all states and shader codes for each.
You can just call the dumpRenderObjectsToTexxt() function with a filename and a pointer to the
sortedObjects_.

Often encountered errors:
- lighting disabled in ShaderGenDesc and black emission color (use different emission color)
- wrong depth-buffer states
- color write disabled
- wrong vertex declaration format
- temporary vertex declaration (it should be a static or member variable)
   The address set to the render object has to be valid after the call to getRenderObject().


If the whole scene seems to be rendered wrong, it is possible that one draw-call causes problems in the OpenGL state machine.
Try to render only a selection of renderobjects until the problematic one is found.

*/
