/** \page NonFixedPipelinePage The non-fixed OpenGL rendering pipeline
On this page we will explain how to use the non-fixed (modern) OpenGL rendering pipeline in OpenFlipper.
First let us introduce the necessary classes.

\section baseNode The BaseNode in the Scenegraph

\section iRenderer The IRenderer interface
The IRenderer interface can be derived from and used to attach a RenderObject via the addRenderObject function from within each node within the Scenegraph that is
to be rendered.

\subsection renderObject Defining RenderObjects
The RenderObject class can be used to define the vertex buffer objects and set further information for the scene nodes.

\section vertexDeclaration Defining the layout of a vertex element
The VertexDeclaration class is used to specify the layout of a vertex element (VertexElement)

\section shaderGenerator Generating GLSL shaders

The \subpage ShaderGenerator_page class can be used to generate default GLSL shader code.
It is possible to have the complete shader generated with typical shading options such as phong or flat shading.
Alternatively the main function can be fully customized via template files or ShaderModifiers.
Template files are specified in ShaderGenDesc::vertexTemplateFile and ShaderGenDesc::fragmentTemplateFile and 
they extend the generated code by a user defined main function. Shader vertex I/O attributes and uniforms can also be
user defined; however, make sure that there is no name conflict with the generated shader code.
Example: A vertex offset operation based on normals is accomplished with the following template file:
\code
void main()
{
  // default vertex transforms are handled by the generator by replacing the SG_VERTEX_BEGIN with generated code
  SG_VERTEX_BEGIN
  
#ifdef SG_NORMALS
  sg_vPosPS = g_mWVP * (inPosition + vec4(inNormal, 0));
#endif
  
  SG_VERTEX_END
}
\endcode

But templates are optional and are not needed to generate shaders for mimicking the fixed function pipeline.
Alternatively, ShaderModifiers are useful for global shading effects which only change few code lines
and are also combinable with each other allowing a more dynamic shader customization.
The Depth-Peeling renderer shows how to use these modifiers.


\subsection shaderCache The Shader Cache
The Shader Cache singleton class should be used to manage the used shaders. You can query a shader
from the cache via a shader description. If it is already available, it will be returned from
the cache. Otherwise, it is compiled and linked. This ensures more efficient and
redundancy free shader management. ( ACG::ShaderCache )


\subsection glslShader The GLSL Shader
The Shader class is a helper class for building and using GLSL programs


\subsection Draw Modes

A DrawMode is a set of properties that describe how to present an object (i.e. wireframe, textured, flat-shaded...).
There are two types of Drawmodes: bitflags and property-based.
Bitflags are a combination of predefined Drawmodes such as SOLID_SMOOTH_SHADED and WIREFRAME.
Afterwards it can be tested with the bitwise & operator whether it contains such an atomic DrawMode.

Property-based draw modes use a different approach by defining a set of properties for an atomic DrawMode.
These settings are stored in the DrawModeProperties structure.
Support for combined drawmodes is possible by adding a new layer for each atomic drawmode.
Each layer is represented by one atomic DrawModeProperties structure.
Initially each property-based draw mode consists of exactly one layer which is equivalent to an atomic draw mode.
If we also want to render the wireframe or halfedge representation of an object in combination with a solid mode,
we can fill out a DrawModeProperties struct for that purpose and call DrawMode::addLayer() to combine wireframe and solid mode.

A scenegraph node can iterate over each layer of a Drawmode via getNumLayers() and getLayer()
and draw its object according to the properties of that layer.

Example:
Draw with gouraud shading:

\code
DrawModeProperties props;
props.lightStage(LIGHTSTAGE_SMOOTH); // lighting should be done in vertex shader
props.normalSource(NORMAL_PER_VERTEX); // use smooth vertex normals

drawMode.setDrawModeProperties(props); // assign to layer 0
\code


Draw with phong lighting:

\code
DrawModeProperties props;
props.lightStage(LIGHTSTAGE_PHONG); // lighting should be done in fragment shader
props.normalSource(NORMAL_PER_VERTEX); // use smooth vertex normals

drawMode.setDrawModeProperties(props); // assign to layer 0
\code


Draw with flat shading and wireframe (2 layers):

\code
// define flat shading properties
DrawModeProperties props;
props.lightStage(LIGHTSTAGE_SMOOTH); // lighting should be done in vertex shader
props.normalSource(NORMAL_PER_FACE); // use per face normals

drawMode.setDrawModeProperties(props); // assign flat shading to layer 0

// define unlit properties for wireframe rendering
props.primitive(PRIMITIVE_WIREFRAME); // use wireframe instead of solid faces
props.lightStage(LIGHTSTAGE_UNLIT); // no lighting 

drawMode.addLayer(&props); // assign wireframe to layer 1
\code

The object is then rendered in two passes (one for each layer) with different shader programs.
Note that the light stage tells the shader generator whether to do the lighting in vertex or fragment shader or to skip it entirely.
Then a combination of lighting functions are added to the shader code based on the light configuration in the ShaderGenDesc structure.

Example based on a DIRECTIONAL, DIRECTIONAL, POINTLIGHT configuration:
\code
sg_cColor.xyz += LitDirLight(sg_vPosVS.xyz, sg_vNormalVS, g_vLightDir_0,  g_cLightAmbient_0,  g_cLightDiffuse_0,  g_cLightSpecular_0);
sg_cColor.xyz += LitDirLight(sg_vPosVS.xyz, sg_vNormalVS, g_vLightDir_1,  g_cLightAmbient_1,  g_cLightDiffuse_1,  g_cLightSpecular_1);
sg_cColor.xyz += LitPointLight(sg_vPosVS.xyz, sg_vNormalVS,  g_vLightPos_2,  g_cLightAmbient_2,  g_cLightDiffuse_2,  g_cLightSpecular_2, g_vLightAtten_2);
\code


*/
