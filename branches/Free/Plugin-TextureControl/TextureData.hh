/*===========================================================================*\
*                                                                            *
*                              OpenFlipper                                   *
*      Copyright (C) 2001-2014 by Computer Graphics Group, RWTH Aachen       *
*                           www.openflipper.org                              *
*                                                                            *
*--------------------------------------------------------------------------- *
*  This file is part of OpenFlipper.                                         *
*                                                                            *
*  OpenFlipper is free software: you can redistribute it and/or modify       *
*  it under the terms of the GNU Lesser General Public License as            *
*  published by the Free Software Foundation, either version 3 of            *
*  the License, or (at your option) any later version with the               *
*  following exceptions:                                                     *
*                                                                            *
*  If other files instantiate templates or use macros                        *
*  or inline functions from this file, or you compile this file and          *
*  link it with other files to produce an executable, this file does         *
*  not by itself cause the resulting executable to be covered by the         *
*  GNU Lesser General Public License. This exception does not however        *
*  invalidate any other reasons why the executable file might be             *
*  covered by the GNU Lesser General Public License.                         *
*                                                                            *
*  OpenFlipper is distributed in the hope that it will be useful,            *
*  but WITHOUT ANY WARRANTY; without even the implied warranty of            *
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *
*  GNU Lesser General Public License for more details.                       *
*                                                                            *
*  You should have received a copy of the GNU LesserGeneral Public           *
*  License along with OpenFlipper. If not,                                   *
*  see <http://www.gnu.org/licenses/>.                                       *
*                                                                            *
\*===========================================================================*/

/*===========================================================================*\
*                                                                            *
*   $Revision$                                                       *
*   $LastChangedBy$                                                *
*   $Date$                     *
*                                                                            *
\*===========================================================================*/

#ifndef TEXTUREDATA_HH
#define TEXTUREDATA_HH

#include <OpenFlipper/common/perObjectData.hh>
#include "TextureParameters.hh"

#include <QString>
#include <QStringList>
#include <ACG/GL/gl.hh>
#include <vector>
#include <map>
#include <cfloat>


enum TextureType { UNSET         = 1 << 0,
                   /// Texture Coordinates are stored on a per Vertex basis
                   VERTEXBASED   = 1 << 1,
                   /// Texture Coordinates are stored on a per Halfedge basis ( per vertex per face )
                   HALFEDGEBASED = 1 << 2,
                   /// Texture coordinates are autogenerated by OpenGL for Environment map
                   ENVIRONMENT   = 1 << 3,
                   /// MultiTexture Mode
                   MULTITEXTURE  = 1 << 4 };

class Texture {
  public :
    Texture();
    
    // copy constructor
    Texture( const Texture& _tex)
    : parameters(_tex.parameters),
    multiTextureList(_tex.multiTextureList),
    name_(_tex.name_),
    textureImageId_(_tex.textureImageId_),
    visibleName_(_tex.visibleName_),
    filename_(_tex.filename_),
    id_(_tex.id_),
    glName_(_tex.glName_),
    dimension_(_tex.dimension_),
    enabled_(_tex.enabled_),
    hidden_(_tex.hidden_),
    dirty_(_tex.dirty_),
    type_(_tex.type_),
    indexMappingProperty_(_tex.indexMappingProperty_)
    {
    }


    void filename( QString _name ) { filename_ = _name; };
    QString filename() { return filename_; };


    void id( int _id ) { id_ = _id; };
    int id() { return id_; };


    void glName( GLuint _glName ) { glName_ = _glName; };
    GLuint glName() { return glName_; };


    void name( QString _name ) { name_ = _name; };
    QString name() { return name_; };

    void visibleName( QString _name ) { visibleName_ = _name; };
    QString visibleName() { return visibleName_; };


    void dimension( uint _dimension ) { dimension_ = _dimension; };
    uint dimension( ) { return dimension_; };


    void enabled( bool _enabled ) { enabled_ = _enabled; };
    bool enabled() { return enabled_; };
    void enable(){ enabled_ = true; };
    void disable(){ enabled_ = false; };

    void hidden( bool _hidden ) { hidden_ = _hidden; };
    bool hidden() { return hidden_; };
    void hide() { hidden_ = true; };

    void dirty( bool _dirty ) { dirty_ = _dirty; };
    bool dirty() { return dirty_; };
    void clean() { dirty_ = false; };
    void setDirty() { dirty_ = true; };

    void textureImageId( int _id) {textureImageId_ = _id;};
    int textureImageId() {return textureImageId_; };


    void type( TextureType _type ) { type_ = _type; };
    TextureType type( ) { return type_; };


    QString indexMappingProperty() { return indexMappingProperty_; };
    void indexMappingProperty( QString _property ) { indexMappingProperty_ = _property; };


    /// Parameters of the texture
    TexParameters parameters;


    /// If this is a multiTexture, the list will contain all textures for this multi Texture node.
    QStringList multiTextureList;

  private:
    /// Texture Name
    QString name_;

    /// The image used as the texture ( Ids are handled by the ImageStore )
    int textureImageId_;

    /// Name visible in the gui
    QString visibleName_;

    /// Filename of the texture
    QString filename_;

    /// Texture id
    int id_;

    /// glName
    GLuint glName_;

    /// dimension
    uint dimension_;

    /// Status
    bool enabled_;

    /// Hidden flag ( If this texture belongs to a multitexture, it will be hidden in the context menu )
    bool hidden_;

    /// does this texture need an update?
    bool dirty_;

    /// Texture Type
    TextureType type_;

    /** If this is a multiTexture, indexMappingProperty_ will point to the property storing the mapping
     * Defaults to the f:textureindex
    */
    QString indexMappingProperty_;

};

class TextureData : public PerObjectData
{

  public :

      /// Constructor
      TextureData();
      /// Destructor
      ~TextureData();
      
      // copy Operator returning an exact copy of this Object
      virtual PerObjectData* copyPerObjectData( ) {
        
        // Create an object copy (This will call all copy constructors of the included data objects! )
        TextureData* copy = new TextureData(*this);
        
        return copy;
      }


      /// Check if a texture exists
      bool textureExists(QString _textureName);


      /// Check if a texture is enabled
      bool isEnabled(QString _textureName);


      /// Enable a given texture
      bool enableTexture(QString _textureName, bool _exclusive = false);

      /// Disable a given texture
      void disableTexture(QString _textureName);

      /// Add a Texture
      int addTexture ( QString _textureName , QString _filename , uint _dimension, GLuint _glName );

      /// Add a Texture ( Based on an existing specification )
      int addTexture ( Texture _texture, GLuint _glName );

      /// Adds a new multiTexture ( This texture will only contain a list of enabled textures for multitexturing )
      bool addMultiTexture( QString _textureName );

      /// Stores the given image in the texture information
      bool setImage( QString _textureName , int _id );

      /*
      /// Delete a given texture
      void deleteTexture(QString _textureName);

      /// get parameters of a given texture
      TexParameters textureParameters(QString _textureName);

      /// Set Parameters for a given texture
      void setTextureParameters(QString _textureName, TexParameters _params);
      */

      /// Get the texture object
      Texture& texture(QString _textureName);

      /// Get reference to the texture vector
      std::vector< Texture >& textures();


      /** This map maps all available textures for the object which this
       *  class belongs to to their GLuint. The MeshNode will use this
       *  map to activate one texture for each face.
       *
       */
      std::map< int, GLuint >* textureMap();

    /** This map is used to store the available Textures and map them to their
     *  corresponding properties.
     */
      std::map< int, std::string >* propertyMap();

  private :

    std::map< int, GLuint> textureMap_;
    std::map< int, std::string> propertyMap_;

    /// internal id for the next texture
    int nextInternalID_;


    /// vector containing all textures of an object
    std::vector< Texture > textures_;


    /// Get the index of a given texture
    int getTextureIndex(QString _textureName);

    Texture noTexture;

};

#endif //TEXTUREDATA_HH
