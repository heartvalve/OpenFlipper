//=============================================================================
//
//                               OpenFlipper
//        Copyright (C) 2008 by Computer Graphics Group, RWTH Aachen
//                           www.openflipper.org
//
//-----------------------------------------------------------------------------
//
//                                License
//
//  OpenFlipper is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  OpenFlipper is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with OpenFlipper.  If not, see <http://www.gnu.org/licenses/>.
//
//-----------------------------------------------------------------------------
//
//   $Revision$
//   $Author$
//   $Date$
//
//=============================================================================





#include <QtGui>

#include "TextureControl.hh"

#include <iostream>
#include <ACG/GL/GLState.hh>

#include "OpenFlipper/BasePlugin/PluginFunctions.hh"
#include "OpenFlipper/common/GlobalOptions.hh"

void TextureControlPlugin::slotTextureAdded( QString _textureName , QString _filename , uint _dimension)
{
  Texture tex;
  tex.name = _textureName;
  tex.filename = _filename;
  tex.dimension = _dimension;
  tex.scale = true;
  tex.clamp_min = FLT_MIN;
  tex.clamp_max = FLT_MAX;
  tex.clamp = false;
  tex.repeat = false;
  tex.center = false;
  tex.abs = false;
  tex.max_val = 1.0;
  tex.type = VERTEXBASED;
  textures_.push_back( tex );

  activeTexture_ = _textureName;

  QAction* new_texture = new QAction(_textureName, this);
  new_texture->setStatusTip(tr("Switch to this Texture"));
  new_texture->setCheckable(true);
  actionGroup_->addAction(new_texture);
  textureMenu_->addAction(new_texture);
  new_texture->setChecked(true);

  textureActions_.push_back(new_texture);

  ///@todo if a texture is added later, update or generate it for all objects
//   emit updateTexture(_textureName,-1);
}

void TextureControlPlugin::slotTextureUpdated( QString _textureName , int _identifier ) {

  BaseObjectData* object;
  if (! PluginFunctions::getObject(  _identifier , object ) ) {
    emit log(LOGERR,"Unable to get Object for id " + QString::number(_identifier) );
    return;
  }

  // Search the list of textures if we have the texture
  int textureid = -1;
  for ( int i = 0 ; i < (int)textures_.size() ; ++i ) {
    if ( textures_[i].name == _textureName ) {
      textureid = i;
      break;
    }
  }


  if ( textureid == -1 ) {
    emit log(LOGERR,"Unable to find texture with name " + _textureName );
    return;
  }

  // Only update if the active texture is the current texture
  if ( activeTexture_ != _textureName)
    return;

  QString filename = OpenFlipper::Options::textureDir().absolutePath() +
                     OpenFlipper::Options::dirSeparator() +
                     textures_[textureid].filename;

  // load to image
  QImage textureImage;
  if ( !textureImage.load( filename ) )
  {
      std::cerr << "Cannot load texture " << filename.toStdString() << "\n";
      return ;
  }

  if( object->dataType( DATA_TRIANGLE_MESH ) ) {
    TriMesh* mesh = PluginFunctions::triMesh(object);
    doUpdateTexture(textureid, *mesh);
    PluginFunctions::triMeshObject(object)->textureNode()->set_repeat(textures_[textureid].repeat);
    PluginFunctions::triMeshObject(object)->setTexture(_textureName,textureImage);

    //TODO
    //textureExists
    //enableTexture
  }

  if ( object->dataType( DATA_POLY_MESH ) ) {
    PolyMesh* mesh = PluginFunctions::polyMesh(object);
    doUpdateTexture(textureid, *mesh);
    PluginFunctions::polyMeshObject(object)->textureNode()->set_repeat(textures_[textureid].repeat);
    PluginFunctions::polyMeshObject(object)->setTexture(_textureName,textureImage);

    //TODO
    //textureExists
    //enableTexture
  }
  emit updateView();

}

template< typename MeshT >
void TextureControlPlugin::doUpdateTexture ( int _textureid, MeshT& _mesh )
{
  if ( textures_[_textureid].type == HALFEDGEBASED ) {
    if (textures_[_textureid].dimension == 1) {

      OpenMesh::HPropHandleT< double > texture;
	  if ( ! _mesh.get_property_handle(texture, textures_[_textureid].name.toStdString() ) ) {
        emit log(LOGERR,"Unable to get property " + textures_[_textureid].name );
        return;
      }

      copyTexture(_textureid, _mesh, texture);

    } else if ( textures_[_textureid].dimension == 2 ) {

      OpenMesh::HPropHandleT< OpenMesh::Vec2d > texture2D;
	  if ( ! _mesh.get_property_handle( texture2D, textures_[_textureid].name.toStdString() ) ) {
        emit log(LOGERR,"Unable to get property " + textures_[_textureid].name);
        return;
      }

      copyTexture(_textureid, _mesh, texture2D);

    } else
      emit log(LOGERR, "Unsupported Texture Dimension " + QString::number(textures_[_textureid].dimension) );
  } else if ( textures_[_textureid].type == VERTEXBASED ) {
    if ( textures_[_textureid].dimension == 1 ) {

      OpenMesh::VPropHandleT< double > texture;
	  if ( ! _mesh.get_property_handle(texture,textures_[_textureid].name.toStdString() ) ) {
        emit log(LOGERR,"Unable to get property " + textures_[_textureid].name );
        return;
      }

        copyTexture(_textureid, _mesh, texture);

      } else if ( textures_[_textureid].dimension == 2 ) {

        OpenMesh::VPropHandleT< OpenMesh::Vec2d >  texture2D;
		  if ( ! _mesh.get_property_handle(texture2D,textures_[_textureid].name.toStdString() ) ) {
          emit log(LOGERR,"Unable to get property " + textures_[_textureid].name );
          return;
        }

        copyTexture(_textureid, _mesh, texture2D);

      } /*else if ( textures_[_textureid].dimension == 3 ) {

        OpenMesh::VPropHandleT< OpenMesh::Vec3d >  scalarField3D;
        if ( ! _mesh.get_property_handle(scalarField3D,textures_[_textureid].name) ) {
          emit log(LOGERR,"Unable to get property " + textures_[_textureid].name );
          return;
        }

        copyTexture(_textureid, _mesh, scalarField3D);

      }*/ else
        emit log(LOGERR, "Unsupported Texture Dimension " + QString::number(textures_[_textureid].dimension) );

    } else
      emit log(LOGERR, "Unsupported Texture type");

}

void TextureControlPlugin::computeValue(int _textureid, double _min, double _max, double& _value) {
   const bool clamp = textures_[_textureid].clamp ;
   const bool center = textures_[_textureid].center;
   const double max_val = textures_[_textureid].max_val;
   const bool abs = textures_[_textureid].abs;
   const double clamp_max = textures_[_textureid].clamp_max;
   const double clamp_min = textures_[_textureid].clamp_min;
   const double scale = fabs(_max) + fabs(_min);
   const bool repeat = textures_[_textureid].repeat;

   // Use absolute value as requested by plugin
   if ( abs )
      _value = fabs(_value);

   // Clamp if requested
   if ( clamp ) {
      if ( _value > clamp_max )
         _value = clamp_max;
      if (_value < clamp_min)
         _value = clamp_min;
   }

   // if the texture should not be repeated, scale to 0..1
   if ( ! repeat ) {
      if (! center ) {
        if ( textures_[_textureid].scale) {
          _value /= scale;
          _value -= _min/scale;
        }
      } else {
         // the values above zero are mapped to 0.5..1 the negative ones to 0.5..0
         if (_value > 0.0) {
            _value /= ( _max * 2.0);
            _value += 0.5;
         } else {
            _value /= ( _min * 2.0);
            _value = 0.5 - _value;
         }
      }
   } else {
      _value -= _min;
      _value *= max_val / (_max - _min);
   }
}

void TextureControlPlugin::slotObjectUpdated(int _identifier)
{
   // Object erased, so do nothing
   if ( _identifier == -1 ) {
      return;
   }

   // Force an update of all textures which are available for the updated object
   for ( uint i = 0 ; i < textures_.size() ; ++i ) {
      emit updateTexture( textures_[i].name , _identifier );
   }

}

void TextureControlPlugin::slotUpdateAllTextures( ) {
   // Force an update of all textures which are available for the updated object
   for ( PluginFunctions::ObjectIterator o_it(PluginFunctions::ALL_OBJECTS) ; o_it != PluginFunctions::objectsEnd(); ++o_it)
      for ( uint i = 0 ; i < textures_.size() ; ++i )
         emit updateTexture( textures_[i].name , o_it->id() );
}

void TextureControlPlugin::slotSetTextureMode(QString _textureName ,QString _mode) {
   int textureid = -1;
   for ( int j = 0 ; j < (int)textures_.size() ; ++j ) {
        if ( textures_[j].name == _textureName ) {
             textureid = j;
             break;
        }
   }

   if ( textureid == -1 ) {
     emit log(LOGERR,"Texture Mode setting requested for " + _textureName + " but texture not found" );
     return;
   }

   int i = 0;
   QString nextString = _mode.section(',',i,i);
   while ( nextString != "" ) {
      QString sectionName = nextString.section('=',0,0);
      QString value = nextString.section('=',1,1);

      if ( sectionName == "clamp" ) {
         if (value == "false") {
              textures_[textureid].clamp = false;
         } else {
              textures_[textureid].clamp = true;
         }
      } else
      if ( sectionName == "clamp_max" ) {
              textures_[textureid].clamp_max = value.toDouble();
      } else
      if ( sectionName == "clamp_min" ) {
              textures_[textureid].clamp_min = value.toDouble();
      } else
      if ( sectionName == "max_val" ) {
              textures_[textureid].max_val = value.toDouble();
      } else
      if ( sectionName == "repeat" ) {
         if (value == "false") {
              textures_[textureid].repeat = false;
         } else {
              textures_[textureid].repeat = true;
         }
      } else
      if ( sectionName == "center" ) {
         if (value == "false") {
              textures_[textureid].center = false;
         } else {
              textures_[textureid].center = true;
         }
      } else
      if ( sectionName == "scale" ) {
         if (value == "false") {
              textures_[textureid].scale = false;
         } else {
              textures_[textureid].scale = true;
         }
      } else
      if ( sectionName == "type" ) {
         if (value == "halfedgebased") {
              textures_[textureid].type = HALFEDGEBASED;
         } else {
              textures_[textureid].type = VERTEXBASED;
         }
      } else
        emit log(LOGERR,"Unknown texture mode : " + sectionName);

      ++i;
      nextString = _mode.section(',',i,i);
   }

   if ( activeTexture_ == _textureName ) {

      // Force an update of all objects
      for ( PluginFunctions::ObjectIterator o_it(PluginFunctions::ALL_OBJECTS) ; o_it != PluginFunctions::objectsEnd(); ++o_it)
         updateTexture(  _textureName , o_it->id() );

      emit updateView();
   }
}

void TextureControlPlugin::pluginsInitialized() {
  // Texture menu
  textureMenu_ = new QMenu(tr("&Texture Control"));

  textureMenu_->setTearOffEnabled(true);

  emit addMenubarAction(textureMenu_->menuAction(), VIEWMENU );

  settingsDialog_ = new texturePropertiesWidget(0);

  connect(settingsDialog_->okButton,SIGNAL(clicked()), this , SLOT (slotTexturePropertiesOk() ) );
  connect(settingsDialog_->applyButton,SIGNAL(clicked()), this , SLOT (slotTexturePropertiesApply() ) );
  connect(settingsDialog_->cancelButton,SIGNAL(clicked()), this , SLOT (slotTexturePropertiesCancel() ) );

  actionGroup_ = new QActionGroup( 0 );
  actionGroup_->setExclusive( true );
  connect( actionGroup_, SIGNAL( triggered( QAction * ) ),
          this, SLOT( slotTextureMenu( QAction * ) ) );

  QAction* AC_Texture_Settings = new QAction(tr("&Texture Settings"), this);
  AC_Texture_Settings->setStatusTip(tr("Set the texture visualization properties"));
  connect(AC_Texture_Settings, SIGNAL(triggered()), this, SLOT(slotSetTextureProperties()));
  textureMenu_->addAction(AC_Texture_Settings);

  textureMenu_->addSeparator();
  textureMenu_->addActions(actionGroup_->actions());
}

void TextureControlPlugin::updateDialog() {
  if ( textures_.size() == 0 )
    return;

  int textureid = -1;
  for ( int i = 0 ; i < (int)textures_.size() ; ++i ) {
      if ( textures_[i].name == activeTexture_ ) {
            textureid = i;
            break;
      }
  }

  if ( textureid == -1 ) {
      emit log(LOGERR,"Active Texture not found");
      return;
  }

  settingsDialog_->repeatBox->setChecked(textures_[textureid].repeat);
  settingsDialog_->clampBox->setChecked(textures_[textureid].clamp);
  settingsDialog_->centerBox->setChecked(textures_[textureid].center);
  settingsDialog_->absBox->setChecked(textures_[textureid].abs);
  QString tmp;
  tmp.setNum(textures_[textureid].max_val);
  settingsDialog_->max_val->setText( tmp );
  tmp.setNum(textures_[textureid].clamp_min);
  settingsDialog_->clamp_min->setText(tmp);
  tmp.setNum(textures_[textureid].clamp_max);
  settingsDialog_->clamp_max->setText(tmp);

  // update plot only when dimension is 1
  if ( textures_[textureid].dimension == 1) {
    std::vector< double > x,y;

    x.push_back(100.0);
    y.push_back(100.0);

    x.push_back(200.0);
    y.push_back(150.0);

    x.push_back(300.0);
    y.push_back(10.0);

    settingsDialog_->setOriginalData(x,y);

//     getOriginalHistogram();

  }
}

void TextureControlPlugin::slotSetTextureProperties() {
  updateDialog();
  if ( textures_.size() == 0 )
      return;

  settingsDialog_->show();
}

void TextureControlPlugin::applyDialogSettings() {
  if ( textures_.size() == 0 )
      return;

  int textureid = -1;
  for ( int i = 0 ; i < (int)textures_.size() ; ++i ) {
        if ( textures_[i].name == activeTexture_ ) {
              textureid = i;
              break;
        }
  }

  if (textureid == -1) {
      emit log(LOGERR,"Unable to get active Texture");
  }

  textures_[textureid].repeat=settingsDialog_->repeatBox->isChecked();
  textures_[textureid].clamp=settingsDialog_->clampBox->isChecked();
  textures_[textureid].center=settingsDialog_->centerBox->isChecked();
  textures_[textureid].abs=settingsDialog_->absBox->isChecked();
  textures_[textureid].scale=settingsDialog_->scaleBox->isChecked();

  QString tmp;
  tmp = settingsDialog_->max_val->text();
  textures_[textureid].max_val = tmp.toDouble();

  tmp = settingsDialog_->clamp_min->text();
  textures_[textureid].clamp_min = tmp.toDouble();

  tmp = settingsDialog_->clamp_max->text();
  textures_[textureid].clamp_max = tmp.toDouble();

  // Update the corresponding meshes
  for ( PluginFunctions::ObjectIterator o_it(PluginFunctions::ALL_OBJECTS) ; o_it != PluginFunctions::objectsEnd(); ++o_it)
      slotTextureUpdated(  activeTexture_ , o_it->id() );

  emit updateView();
}

void TextureControlPlugin::slotTexturePropertiesOk() {
  applyDialogSettings();
  settingsDialog_->hide();
}

  void TextureControlPlugin::slotTexturePropertiesApply() {
    applyDialogSettings();
}

void TextureControlPlugin::slotTexturePropertiesCancel() {
    settingsDialog_->hide();
}


void TextureControlPlugin::slotTextureMenu(QAction* _action) {
  if ( activeTexture_ !=  _action->text() ) {
      activeTexture_ =  _action->text();

      // Force an update of all objects
      for ( PluginFunctions::ObjectIterator o_it(PluginFunctions::ALL_OBJECTS) ; o_it != PluginFunctions::objectsEnd(); ++o_it)
        slotTextureUpdated(  _action->text() , o_it->id() );

      updateDialog();

      PluginFunctions::setDrawMode( ACG::SceneGraph::DrawModes::SOLID_TEXTURED_SHADED );
  }
}

void TextureControlPlugin::slotSwitchTexture( QString _textureName ) {
  int textureid = -1;
  for ( int i = 0 ; i < (int)textures_.size() ; ++i ) {
        if ( textures_[i].name == _textureName ) {
              textureid = i;
              break;
        }
  }

  if (textureid == -1) {
    emit log(LOGERR,"Unable to switch to texture " + _textureName + " (not found)");
    return;
  }

  PluginFunctions::setDrawMode( ACG::SceneGraph::DrawModes::SOLID_TEXTURED_SHADED );

  if ( activeTexture_ !=  _textureName ) {
    activeTexture_ =  _textureName;

    // Force an update of all objects
    for ( PluginFunctions::ObjectIterator o_it(PluginFunctions::ALL_OBJECTS) ; o_it != PluginFunctions::objectsEnd(); ++o_it)
        slotTextureUpdated(  _textureName , o_it->id() );

    updateDialog();

    QList<QAction *> menuEntries = actionGroup_->actions();

    for ( int i = 0 ; i < menuEntries.size(); ++i ) {
      if ( menuEntries[i]->text() == _textureName )
        menuEntries[i]->setChecked(true);
    }
  }
}


Q_EXPORT_PLUGIN2( texturecontrolplugin , TextureControlPlugin );

